        Тут всё про серверную часть.


A view from the moon
===

Контестирующая система


A view from the near space
===

Немного надёжная и немного распределенная контестирующая система на erlang.
Позиционирует саму себя как аналог ejudge. 

Поможет вам сделать:

* Проведение онлайн соревнований.
* Проведение виртуальных соревнований.
* Тренировки.
* Архив.

Всё с ACL'ом, AJAX'ом и новогодними питардами.


A view from the cuckoo's eye
===

Возможности на контесте:

* Посмотреть условия на разных языках;
* Отослать решение (на разных языках программирования);
* Посмотреть турнирную таблицу;
* Задать вопрос жюри;
* Комнаты? FIXME
* Запуск на стороне сервера.

ACL:

* Есть пользователи и ресурсы, ACL отвечает за связи между ними.
* Пользователь входит в одну или более групп.
* Группы могут быть вложеными.
* Пример ресурса -- контест, задача. Ресурсом также может быть возвожность
  чего-либо сделать, например создать контест, выгрузить список
  пользователей.
* Если существует связь между группой, в которую входит пользователь,
  и ресурсом, то права доступа берутся из неё. Если таких групп несколько,
  то берется максимум из правил.
* Над тем, что находится внутри правил ещё надо подумать. (rwx -- смотреть,
  менять, сдавать решения). FIXME

Условие задач:

* Разные языки.
* Простой HTML.
* Возможно рендерер формул теха.
* Есть презентатор -- переводит задачу в то, что мы должны показать.

Проверка решений:

* Проверка осуществляется на одной машине последовательностью judge'й (он же
  судья). Для соревнований типа ACM ICPC достаточно одного (типа runlib).
* Порядок выполнения судей постоянен и указывается при оформлении задачи;
  там же указываются параметры для судей, например лимит по памяти для
  задачи.
* Судьи является частью разрабатываемой системы, то есть они не загружаются
  с задачами.
* Судья возвращает два вердикта: первый -- флаг продолжения проверки судьями,
  второй необходим для рейтинга решения.
* После проверки задачи судьями, орбитором выставляется результирующая
  оценка сданного решения.
* После выстановления оценки орбитором, главным орбитором производются
  изменения в турнирной таблице.

Подготовка задач:

* Задачи загружаются архивом.
* Описание задачи, последовательности judge'й, выбор орбиторов происходит из
  json-файла из архива.

Регистрация:

* Пользователи могут регистрироваться самостоятельно, если это разрешено.
* Модерация регистраций пользователей.
* Загрузка файла-списков пользователей с указанием группы (групп), в которую
  будут добавлены пользователи.

FIXME мб ещё что-то.


A close view
===

Есть несколько ролей. Каждая роль может быть выполнена на некотором множестве
нод. Множества задаются явно.

То, что впередях -- frontend:

* Впереди системы стоит web-server yaws.
* Он проводит роутинг, презентацию задач и шаблонизацию.
* Функции проверки доступа тут.
* Должен дергать (за ниточки RabbitMQ) всю оставшуюся систему.
* WebSockets для "волнительных" моментов. FIXME надо подумать как их вписать
  лучше.
* Шаблонизация может быть на основе возможностей yaws.
* Надо подумать о том, чтобы сделать уникальные токены для каждой формы,
  чтобы избежать разных уязвимостей. Also keep in mind server only cookies.

То, что проверяет -- worker:

* Получает решение на проверку.
* По необходимости запрашивает задачу из Riak.
* Прогоняет задачу по судьям, получает результат у орбитора. Результат
  посылается по RabbitMQ главным орбиторам.
* Сборщик мусора за судьями.
* Должен как-то отправлять результат о статусе проверки на frontend.

То, что составляет турнирную таблицу -- main orbiter:

* Держит таблицы активных соревнований в памяти, складывает в Riak.
* Принимает сообщение от орбиторов, меняет турнирную таблицу.
* При изменение таблицы оповещает все frontend'ы.

Кроме этих нод будут ещё ноды выделеные под Riak, RabbitMQ, возможно какие-то
балансеры. Не совсем понятно, как именно будет реализован ACL, поиск по задачам.
Нужно подумать о том, как реализовать с или без PostgreSQL.

FIXME далее идет много приблизительных цифр.

Слово о нагрузках: система должна выдержать контест с максимальным участием в
6000 человек. При этом, в начале контеста (первые 15 минут) ожидается самая
большая активность: три четверти сделают попытку по первой задаче, плюс ещё
треть от всей аудитории сделает попытку по второй. То есть за 15 минут можно
ожидать 6500 задач на проверку. На проверку каждой задачи уходит в среднем
40 -- 90 секунд процессорного времени. То есть каждую минуту необходимо 500
минут процессорного времени -- это максимальный пик.

На протяжении двух-часового контеста из пяти задач в среднем делается 6 попыток
каждым участником. Аналогичнымы расчётами получаем в среднем 300 посылок решений
каждую минуту.

Если смотреть на Amazon EC2, то поскольку тут в основном нагрузка на процессор,
то для worker лучше всего использовать High-CPU instances. Для контеста максимум
понадобится 500/8 = 63 ноды 8-головых воркеров.

Запросы на проверку решения поступают на главного орбитора. На проверяющем
ядре находится одновременно 2 проверки решений: активная и следующая за ней в
очереди. То есть на проверяющей ноде находится максимум 2 * (количество ядер)
решений.

О нагрузке на frontend. Все 6000 человек должны получить условие первой задачи в
первых секундах после начала контеста. В хорошем случае это выльется в один
запрос с клиента, на который должен последовать закешированный json-ответ.

А какие ваши идеи?


vim: ts=4 sw=4 et tw=80 ft=markdown

